// Code generated by mockery v2.53.3. DO NOT EDIT.

package mock

import (
	context "context"

	entity "github.com/ptrvsrg/crack-hash/manager/internal/persistence/entity"
	mock "github.com/stretchr/testify/mock"

	primitive "go.mongodb.org/mongo-driver/bson/primitive"
)

// HashCrackSubtaskMock is an autogenerated mock type for the HashCrackSubtask type
type HashCrackSubtaskMock struct {
	mock.Mock
}

type HashCrackSubtaskMock_Expecter struct {
	mock *mock.Mock
}

func (_m *HashCrackSubtaskMock) EXPECT() *HashCrackSubtaskMock_Expecter {
	return &HashCrackSubtaskMock_Expecter{mock: &_m.Mock}
}

// Create provides a mock function with given fields: ctx, task
func (_m *HashCrackSubtaskMock) Create(ctx context.Context, task *entity.HashCrackSubtask) error {
	ret := _m.Called(ctx, task)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.HashCrackSubtask) error); ok {
		r0 = rf(ctx, task)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HashCrackSubtaskMock_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type HashCrackSubtaskMock_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - task *entity.HashCrackSubtask
func (_e *HashCrackSubtaskMock_Expecter) Create(ctx interface{}, task interface{}) *HashCrackSubtaskMock_Create_Call {
	return &HashCrackSubtaskMock_Create_Call{Call: _e.mock.On("Create", ctx, task)}
}

func (_c *HashCrackSubtaskMock_Create_Call) Run(run func(ctx context.Context, task *entity.HashCrackSubtask)) *HashCrackSubtaskMock_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.HashCrackSubtask))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_Create_Call) Return(_a0 error) *HashCrackSubtaskMock_Create_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *HashCrackSubtaskMock_Create_Call) RunAndReturn(run func(context.Context, *entity.HashCrackSubtask) error) *HashCrackSubtaskMock_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAll provides a mock function with given fields: ctx, tasks
func (_m *HashCrackSubtaskMock) CreateAll(ctx context.Context, tasks []*entity.HashCrackSubtask) error {
	ret := _m.Called(ctx, tasks)

	if len(ret) == 0 {
		panic("no return value specified for CreateAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*entity.HashCrackSubtask) error); ok {
		r0 = rf(ctx, tasks)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HashCrackSubtaskMock_CreateAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAll'
type HashCrackSubtaskMock_CreateAll_Call struct {
	*mock.Call
}

// CreateAll is a helper method to define mock.On call
//   - ctx context.Context
//   - tasks []*entity.HashCrackSubtask
func (_e *HashCrackSubtaskMock_Expecter) CreateAll(ctx interface{}, tasks interface{}) *HashCrackSubtaskMock_CreateAll_Call {
	return &HashCrackSubtaskMock_CreateAll_Call{Call: _e.mock.On("CreateAll", ctx, tasks)}
}

func (_c *HashCrackSubtaskMock_CreateAll_Call) Run(run func(ctx context.Context, tasks []*entity.HashCrackSubtask)) *HashCrackSubtaskMock_CreateAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*entity.HashCrackSubtask))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_CreateAll_Call) Return(_a0 error) *HashCrackSubtaskMock_CreateAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *HashCrackSubtaskMock_CreateAll_Call) RunAndReturn(run func(context.Context, []*entity.HashCrackSubtask) error) *HashCrackSubtaskMock_CreateAll_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAllByIDs provides a mock function with given fields: ctx, ids
func (_m *HashCrackSubtaskMock) DeleteAllByIDs(ctx context.Context, ids []primitive.ObjectID) error {
	ret := _m.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllByIDs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []primitive.ObjectID) error); ok {
		r0 = rf(ctx, ids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HashCrackSubtaskMock_DeleteAllByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAllByIDs'
type HashCrackSubtaskMock_DeleteAllByIDs_Call struct {
	*mock.Call
}

// DeleteAllByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []primitive.ObjectID
func (_e *HashCrackSubtaskMock_Expecter) DeleteAllByIDs(ctx interface{}, ids interface{}) *HashCrackSubtaskMock_DeleteAllByIDs_Call {
	return &HashCrackSubtaskMock_DeleteAllByIDs_Call{Call: _e.mock.On("DeleteAllByIDs", ctx, ids)}
}

func (_c *HashCrackSubtaskMock_DeleteAllByIDs_Call) Run(run func(ctx context.Context, ids []primitive.ObjectID)) *HashCrackSubtaskMock_DeleteAllByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]primitive.ObjectID))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_DeleteAllByIDs_Call) Return(_a0 error) *HashCrackSubtaskMock_DeleteAllByIDs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *HashCrackSubtaskMock_DeleteAllByIDs_Call) RunAndReturn(run func(context.Context, []primitive.ObjectID) error) *HashCrackSubtaskMock_DeleteAllByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllByStatus provides a mock function with given fields: ctx, status
func (_m *HashCrackSubtaskMock) GetAllByStatus(ctx context.Context, status entity.HashCrackSubtaskStatus) ([]*entity.HashCrackSubtask, error) {
	ret := _m.Called(ctx, status)

	if len(ret) == 0 {
		panic("no return value specified for GetAllByStatus")
	}

	var r0 []*entity.HashCrackSubtask
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, entity.HashCrackSubtaskStatus) ([]*entity.HashCrackSubtask, error)); ok {
		return rf(ctx, status)
	}
	if rf, ok := ret.Get(0).(func(context.Context, entity.HashCrackSubtaskStatus) []*entity.HashCrackSubtask); ok {
		r0 = rf(ctx, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.HashCrackSubtask)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, entity.HashCrackSubtaskStatus) error); ok {
		r1 = rf(ctx, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HashCrackSubtaskMock_GetAllByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllByStatus'
type HashCrackSubtaskMock_GetAllByStatus_Call struct {
	*mock.Call
}

// GetAllByStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - status entity.HashCrackSubtaskStatus
func (_e *HashCrackSubtaskMock_Expecter) GetAllByStatus(ctx interface{}, status interface{}) *HashCrackSubtaskMock_GetAllByStatus_Call {
	return &HashCrackSubtaskMock_GetAllByStatus_Call{Call: _e.mock.On("GetAllByStatus", ctx, status)}
}

func (_c *HashCrackSubtaskMock_GetAllByStatus_Call) Run(run func(ctx context.Context, status entity.HashCrackSubtaskStatus)) *HashCrackSubtaskMock_GetAllByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(entity.HashCrackSubtaskStatus))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_GetAllByStatus_Call) Return(_a0 []*entity.HashCrackSubtask, _a1 error) *HashCrackSubtaskMock_GetAllByStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *HashCrackSubtaskMock_GetAllByStatus_Call) RunAndReturn(run func(context.Context, entity.HashCrackSubtaskStatus) ([]*entity.HashCrackSubtask, error)) *HashCrackSubtaskMock_GetAllByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllByTaskID provides a mock function with given fields: ctx, taskID
func (_m *HashCrackSubtaskMock) GetAllByTaskID(ctx context.Context, taskID primitive.ObjectID) ([]*entity.HashCrackSubtask, error) {
	ret := _m.Called(ctx, taskID)

	if len(ret) == 0 {
		panic("no return value specified for GetAllByTaskID")
	}

	var r0 []*entity.HashCrackSubtask
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID) ([]*entity.HashCrackSubtask, error)); ok {
		return rf(ctx, taskID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID) []*entity.HashCrackSubtask); ok {
		r0 = rf(ctx, taskID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.HashCrackSubtask)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, primitive.ObjectID) error); ok {
		r1 = rf(ctx, taskID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HashCrackSubtaskMock_GetAllByTaskID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllByTaskID'
type HashCrackSubtaskMock_GetAllByTaskID_Call struct {
	*mock.Call
}

// GetAllByTaskID is a helper method to define mock.On call
//   - ctx context.Context
//   - taskID primitive.ObjectID
func (_e *HashCrackSubtaskMock_Expecter) GetAllByTaskID(ctx interface{}, taskID interface{}) *HashCrackSubtaskMock_GetAllByTaskID_Call {
	return &HashCrackSubtaskMock_GetAllByTaskID_Call{Call: _e.mock.On("GetAllByTaskID", ctx, taskID)}
}

func (_c *HashCrackSubtaskMock_GetAllByTaskID_Call) Run(run func(ctx context.Context, taskID primitive.ObjectID)) *HashCrackSubtaskMock_GetAllByTaskID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(primitive.ObjectID))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_GetAllByTaskID_Call) Return(_a0 []*entity.HashCrackSubtask, _a1 error) *HashCrackSubtaskMock_GetAllByTaskID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *HashCrackSubtaskMock_GetAllByTaskID_Call) RunAndReturn(run func(context.Context, primitive.ObjectID) ([]*entity.HashCrackSubtask, error)) *HashCrackSubtaskMock_GetAllByTaskID_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllByTaskIDs provides a mock function with given fields: ctx, taskIDs
func (_m *HashCrackSubtaskMock) GetAllByTaskIDs(ctx context.Context, taskIDs []primitive.ObjectID) ([]*entity.HashCrackSubtask, error) {
	ret := _m.Called(ctx, taskIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetAllByTaskIDs")
	}

	var r0 []*entity.HashCrackSubtask
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []primitive.ObjectID) ([]*entity.HashCrackSubtask, error)); ok {
		return rf(ctx, taskIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []primitive.ObjectID) []*entity.HashCrackSubtask); ok {
		r0 = rf(ctx, taskIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.HashCrackSubtask)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []primitive.ObjectID) error); ok {
		r1 = rf(ctx, taskIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HashCrackSubtaskMock_GetAllByTaskIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllByTaskIDs'
type HashCrackSubtaskMock_GetAllByTaskIDs_Call struct {
	*mock.Call
}

// GetAllByTaskIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - taskIDs []primitive.ObjectID
func (_e *HashCrackSubtaskMock_Expecter) GetAllByTaskIDs(ctx interface{}, taskIDs interface{}) *HashCrackSubtaskMock_GetAllByTaskIDs_Call {
	return &HashCrackSubtaskMock_GetAllByTaskIDs_Call{Call: _e.mock.On("GetAllByTaskIDs", ctx, taskIDs)}
}

func (_c *HashCrackSubtaskMock_GetAllByTaskIDs_Call) Run(run func(ctx context.Context, taskIDs []primitive.ObjectID)) *HashCrackSubtaskMock_GetAllByTaskIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]primitive.ObjectID))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_GetAllByTaskIDs_Call) Return(_a0 []*entity.HashCrackSubtask, _a1 error) *HashCrackSubtaskMock_GetAllByTaskIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *HashCrackSubtaskMock_GetAllByTaskIDs_Call) RunAndReturn(run func(context.Context, []primitive.ObjectID) ([]*entity.HashCrackSubtask, error)) *HashCrackSubtaskMock_GetAllByTaskIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetByTaskIDAndPartNumber provides a mock function with given fields: ctx, taskID, partNumber
func (_m *HashCrackSubtaskMock) GetByTaskIDAndPartNumber(ctx context.Context, taskID primitive.ObjectID, partNumber int) (*entity.HashCrackSubtask, error) {
	ret := _m.Called(ctx, taskID, partNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetByTaskIDAndPartNumber")
	}

	var r0 *entity.HashCrackSubtask
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID, int) (*entity.HashCrackSubtask, error)); ok {
		return rf(ctx, taskID, partNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID, int) *entity.HashCrackSubtask); ok {
		r0 = rf(ctx, taskID, partNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.HashCrackSubtask)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, primitive.ObjectID, int) error); ok {
		r1 = rf(ctx, taskID, partNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByTaskIDAndPartNumber'
type HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call struct {
	*mock.Call
}

// GetByTaskIDAndPartNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - taskID primitive.ObjectID
//   - partNumber int
func (_e *HashCrackSubtaskMock_Expecter) GetByTaskIDAndPartNumber(ctx interface{}, taskID interface{}, partNumber interface{}) *HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call {
	return &HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call{Call: _e.mock.On("GetByTaskIDAndPartNumber", ctx, taskID, partNumber)}
}

func (_c *HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call) Run(run func(ctx context.Context, taskID primitive.ObjectID, partNumber int)) *HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(primitive.ObjectID), args[2].(int))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call) Return(_a0 *entity.HashCrackSubtask, _a1 error) *HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call) RunAndReturn(run func(context.Context, primitive.ObjectID, int) (*entity.HashCrackSubtask, error)) *HashCrackSubtaskMock_GetByTaskIDAndPartNumber_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, task
func (_m *HashCrackSubtaskMock) Update(ctx context.Context, task *entity.HashCrackSubtask) error {
	ret := _m.Called(ctx, task)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.HashCrackSubtask) error); ok {
		r0 = rf(ctx, task)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HashCrackSubtaskMock_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type HashCrackSubtaskMock_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - task *entity.HashCrackSubtask
func (_e *HashCrackSubtaskMock_Expecter) Update(ctx interface{}, task interface{}) *HashCrackSubtaskMock_Update_Call {
	return &HashCrackSubtaskMock_Update_Call{Call: _e.mock.On("Update", ctx, task)}
}

func (_c *HashCrackSubtaskMock_Update_Call) Run(run func(ctx context.Context, task *entity.HashCrackSubtask)) *HashCrackSubtaskMock_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.HashCrackSubtask))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_Update_Call) Return(_a0 error) *HashCrackSubtaskMock_Update_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *HashCrackSubtaskMock_Update_Call) RunAndReturn(run func(context.Context, *entity.HashCrackSubtask) error) *HashCrackSubtaskMock_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAll provides a mock function with given fields: ctx, tasks
func (_m *HashCrackSubtaskMock) UpdateAll(ctx context.Context, tasks []*entity.HashCrackSubtask) error {
	ret := _m.Called(ctx, tasks)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*entity.HashCrackSubtask) error); ok {
		r0 = rf(ctx, tasks)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HashCrackSubtaskMock_UpdateAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAll'
type HashCrackSubtaskMock_UpdateAll_Call struct {
	*mock.Call
}

// UpdateAll is a helper method to define mock.On call
//   - ctx context.Context
//   - tasks []*entity.HashCrackSubtask
func (_e *HashCrackSubtaskMock_Expecter) UpdateAll(ctx interface{}, tasks interface{}) *HashCrackSubtaskMock_UpdateAll_Call {
	return &HashCrackSubtaskMock_UpdateAll_Call{Call: _e.mock.On("UpdateAll", ctx, tasks)}
}

func (_c *HashCrackSubtaskMock_UpdateAll_Call) Run(run func(ctx context.Context, tasks []*entity.HashCrackSubtask)) *HashCrackSubtaskMock_UpdateAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*entity.HashCrackSubtask))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_UpdateAll_Call) Return(_a0 error) *HashCrackSubtaskMock_UpdateAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *HashCrackSubtaskMock_UpdateAll_Call) RunAndReturn(run func(context.Context, []*entity.HashCrackSubtask) error) *HashCrackSubtaskMock_UpdateAll_Call {
	_c.Call.Return(run)
	return _c
}

// WithTransaction provides a mock function with given fields: ctx, fn
func (_m *HashCrackSubtaskMock) WithTransaction(ctx context.Context, fn func(context.Context) (any, error)) (any, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(context.Context) (any, error)) (any, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(context.Context) (any, error)) any); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(context.Context) (any, error)) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HashCrackSubtaskMock_WithTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTransaction'
type HashCrackSubtaskMock_WithTransaction_Call struct {
	*mock.Call
}

// WithTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(context.Context)(any , error)
func (_e *HashCrackSubtaskMock_Expecter) WithTransaction(ctx interface{}, fn interface{}) *HashCrackSubtaskMock_WithTransaction_Call {
	return &HashCrackSubtaskMock_WithTransaction_Call{Call: _e.mock.On("WithTransaction", ctx, fn)}
}

func (_c *HashCrackSubtaskMock_WithTransaction_Call) Run(run func(ctx context.Context, fn func(context.Context) (any, error))) *HashCrackSubtaskMock_WithTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(context.Context) (any, error)))
	})
	return _c
}

func (_c *HashCrackSubtaskMock_WithTransaction_Call) Return(_a0 any, _a1 error) *HashCrackSubtaskMock_WithTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *HashCrackSubtaskMock_WithTransaction_Call) RunAndReturn(run func(context.Context, func(context.Context) (any, error)) (any, error)) *HashCrackSubtaskMock_WithTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewHashCrackSubtaskMock creates a new instance of HashCrackSubtaskMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHashCrackSubtaskMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *HashCrackSubtaskMock {
	mock := &HashCrackSubtaskMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
